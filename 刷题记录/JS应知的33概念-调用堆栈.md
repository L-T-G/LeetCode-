每天刷一个小知识点啦~~~

[JavaScript开发者应懂的33个概念](https://github.com/stephentian/33-js-concepts#1-%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88)

# 1.调用堆栈

### 调用堆栈

参考博客：

> [Call Stack -MDN](https://developer.mozilla.org/zh-CN/docs/Glossary/Call_stack)





Call Stack（调用栈）

调用栈是**解释器**（比如浏览器中的JavaScript解释器）**追踪函数执行流的一种机制**

作用是啥，作用就是通过这种机制，我们能够追踪到哪个函数正在执行，执行的函数体中又调用了哪个函数

- 每调用一个函数，解释器就会把该函数添加进调用栈并开始执行
- 正在调用栈中执行的函数还调用了其他函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行。（**这个意思是当用到了新函数会把他添加到调用栈，然后直接用，用完就出栈？**）
- 当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余代码
- 当分配的调用栈空间被占满时，会引发“堆栈溢出”错误

看来还真是这样，以下面的函数为例，我们看一看**调用栈**是如何工作的

```js
function greeting() {
   // [1] Some codes here
   sayHi();
   // [2] Some codes here
}
function sayHi() {
   return "Hi!";
}

// 调用 `greeting` 函数
greeting();

// [3] Some codes here
```

上面的代码会按照这样的流程执行：

[1] 忽略前面所有函数的定义bulabula，直到greeting()函数被调用

[2] 把greeting()添加进调用栈列表

[3] 并执行greeting()函数体中的所有代码

> 此时的调用栈列表：
>
> -greetiing

[4] 当代码执行到sayHi()时，该函数被调用

[5]把sayHi()添加进调用栈

[6] 执行sayHi()函数体中的代码，直到全部执行完毕

> 调用栈列表：
>
> -sayHi
>
> -greeting

[7] 返回来继续执行greeting()函数体中sayHi()后面的代码

[8] 删除调用栈列表中的sayHi()函数

[9] 当greeting()函数体中的代码全部执行完毕，返回到调用greeting()的代码行，继续执行剩下的代码

> 调用栈列表：
>
> -greeting

[10] 删除调用栈列表中的greeting()函数



一开始，调用栈是空的，随后，每当有函数被调用都会自动地添加进调用栈，执行完函数体中的代码后，调用栈又会自动的移除这个函数，最后，又得到一个空的调用栈





### JavaScript如何工作：对引擎、运行时、调用堆栈的概述

参考博客：

> [JavaScript如何工作：对引擎、运行时、调用堆栈的概述](https://juejin.cn/post/6844903510538993671)

JavaScript是单线程的，或者它是使用回调队列的

在这篇文章中，详细的介绍了这些概念，解释了JavaScript是怎么工作的

了解了这些细节，就能利用这些提供的API写出更好的，非阻塞的请求出来

#### JavaScript引擎

JavaScript最流行的引擎是谷歌的V8引擎，被使用再Chrome以及Node中

引擎主要由两部分组成：

![image-20210712175047869](D:\学习笔记\截图文件\image-20210712175047869.png)

- 内存堆：这是内存分配发生的地方
- 调用堆：这是代码执行时的地方

#### 运行时

有些浏览器的API经常被使用到(比如setTimeout)

但是，这些API不是引擎提供的，也就是说还有很多引擎之外的API

把这些统称为浏览器提供的Web API，比如DOM、AJAX、setTimeout

还有事件循环和回调队列

![image-20210712180118869](D:\学习笔记\截图文件\image-20210712180118869.png)

#### 调用栈

JavaScript是一门单线程的语言，这意味着它只有一个调用栈，

也就是，同一时间只能做一件事

调用栈是一种**数据结构**，它记录我们在程序中的位置。

当我们运行到一个函数，就会将其放置到栈顶

当函数返回的时候，就会将这个函数从栈顶弹出，这就是调用栈做的事情

**它准确的告诉了我们当前正在执行的是什么东西**

每一个进入调用栈的都称为**调用帧**，这让我们能清楚的知道当异常发生的时候，堆栈追踪是怎样被构造的

以下面代码为例

![image-20210712211318692](D:\学习笔记\截图文件\image-20210712211318692.png)

![image-20210712211336098](D:\学习笔记\截图文件\image-20210712211336098.png)

“**堆栈溢出**”，当你达到的调用栈最大的大小的时候就会发生这种情况

![image-20210712211414847](D:\学习笔记\截图文件\image-20210712211414847.png)

![image-20210712211421805](D:\学习笔记\截图文件\image-20210712211421805.png)

![image-20210712211428924](D:\学习笔记\截图文件\image-20210712211428924.png)

#### 并发与事件循环

这个博客里没说清楚，大爷的

先看下一个，明天回来看这个



### 理解 JavaScript 中的执行上下文和执行栈

> 参考博客：[理解 JavaScript 中的执行上下文和执行栈](https://juejin.cn/post/6844903682283143181)

#### 什么是执行上下文

执行上下文是评估和执行JavaScript代码的环境的抽象概念

每当JavaScript代码在运行的时候，都是在执行上下文中运行

JavaScript中有三种执行上下文类型：

- **全局执行上下文**：这是默认或者说基础的上下文，任何不在函数内部的代码都是在全局上下文中，它会执行两件事：1.创建一个全局的window对象（浏览器的情况下），2.设置**this**的值等于这个全局对象，一个程序中只会有一个全局执行上下文。
- **函数执行上下文**：每当一个函数被调用时，都会为该函数创建一个新的上下文，每个函数都有自己的执行上下文，是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会**按定义的顺序**执行一系列步骤
- **Eval函数执行上下文**：执行在**eval**函数内部的代码也会有属于自己的执行上下文，但由于JavaScript开发者并不经常使用eval，所以忽略

#### 执行栈

也就是调用栈，是拥有一种LIFO(后进先出)数据结构的栈，被**用来存储代码运行时创建的所有执行上下文**

当JavaScript引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈，每当引擎遇到一个函数调用，它就会为该函数创建一个新的执行上下文并压入栈的顶部。

引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。

以下面的代码为例：

```js
let a = 'Hello World!';

function first() {
  console.log('Inside first function');
  second();
  console.log('Again inside first function');
}

function second() {
  console.log('Inside second function');
}

first();
console.log('Inside Global Execution Context');

```

![image-20210712215715958](D:\学习笔记\截图文件\image-20210712215715958.png)

> 上述代码的执行上下文栈。
>
> 当上述代码在浏览器加载时，JavaScript 引擎创建了一个全局执行上下文并把它压入当前执行栈。当遇到 `first()` 函数调用时，JavaScript 引擎为该函数创建一个新的执行上下文并把它压入当前执行栈的顶部。
>
> 当从 `first()` 函数内部调用 `second()` 函数时，JavaScript 引擎为 `second()` 函数创建了一个新的执行上下文并把它压入当前执行栈的顶部。当 `second()` 函数执行完毕，它的执行上下文会从当前栈弹出，并且控制流程到达下一个执行上下文，即 `first()` 函数的执行上下文。
>
> 当 `first()` 执行完毕，它的执行上下文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文。

#### 怎么创建执行上下文？

已经看到了JavaScript如何管理执行上下文了，现在让我们来了解下JavaScript引擎怎样创建执行上下文

创建执行上下文有两个阶段：

（1）创建阶段

（2）执行阶段



**创建阶段**：

1.**this**值的确定，也就是**this的绑定**

2.创建**词法环境**组件

3.创建**变量环境**组件

![image-20210712220334793](D:\学习笔记\截图文件\image-20210712220334793.png)

